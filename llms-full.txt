# griffe-pydantic

> Griffe extension for Pydantic.

# Usage

# griffe-pydantic

[Griffe](https://mkdocstrings.github.io/griffe/) extension for [Pydantic](https://github.com/pydantic/pydantic).

## Installation

```
pip install griffe-pydantic
```

## Usage

### Command-line

```
griffe dump mypackage -e griffe_pydantic
```

See [command-line usage in Griffe's documentation](https://mkdocstrings.github.io/griffe/extensions/#on-the-command-line).

### Python

```
import griffe

griffe.load(
    "mypackage",
    extensions=griffe.load_extensions(
        [{"griffe_pydantic": {"schema": True}}]
    )
)
```

See [programmatic usage in Griffe's documentation](https://mkdocstrings.github.io/griffe/extensions/#programmatically).

### MkDocs

mkdocs.yml

```
plugins:
- mkdocstrings:
    handlers:
      python:
        options:
          extensions:
          - griffe_pydantic:
              schema: true
```

See [MkDocs usage in Griffe's documentation](https://mkdocstrings.github.io/griffe/extensions/#in-mkdocs).

## Sponsors

## Examples

```
from typing import Any
from pydantic import field_validator, model_validator, ConfigDict, BaseModel, Field


class ExampleModel(BaseModel):
    """An example model."""

    model_config = ConfigDict(frozen=False)

    field_without_default: str
    """Shows the *[Required]* marker in the signature."""

    field_plain_with_validator: int = 100
    """Show standard field with type annotation."""

    field_with_validator_and_alias: str = Field("FooBar", alias="BarFoo", validation_alias="BarFoo")
    """Shows corresponding validator with link/anchor."""

    field_with_constraints_and_description: int = Field(
        default=5, ge=0, le=100, description="Shows constraints within doc string."
    )

    @field_validator("field_with_validator_and_alias", "field_without_default", mode="before")
    @classmethod
    def check_max_length_ten(cls, v) -> str:
        """Show corresponding field with link/anchor."""
        if len(v) >= 10:
            raise ValueError("No more than 10 characters allowed")
        return v

    @model_validator(mode="before")
    @classmethod
    def lowercase_only(cls, data: dict[str, Any]) -> dict[str, Any]:
        """Ensure that the field without a default is lowercase."""
        if isinstance(data.get("field_without_default"), str):
            data["field_without_default"] = data["field_without_default"].lower()
        return data
```

### ExampleModel

Bases: `BaseModel`

An example model.

Methods:

- **`check_max_length_ten`** – Show corresponding field with link/anchor.
- **`lowercase_only`** – Ensure that the field without a default is lowercase.

Attributes:

- **`field_plain_with_validator`** (`int`) – Show standard field with type annotation.
- **`field_with_validator_and_alias`** (`str`) – Shows corresponding validator with link/anchor.
- **`field_without_default`** (`str`) – Shows the [Required] marker in the signature.

#### field_plain_with_validator

```
field_plain_with_validator: int = 100
```

Show standard field with type annotation.

#### field_with_validator_and_alias

```
field_with_validator_and_alias: str = Field(
    "FooBar", alias="BarFoo", validation_alias="BarFoo"
)
```

Shows corresponding validator with link/anchor.

#### field_without_default

```
field_without_default: str
```

Shows the *[Required]* marker in the signature.

#### check_max_length_ten

```
check_max_length_ten(v) -> str
```

Show corresponding field with link/anchor.

Source code in `docs/examples/model_noext.py`

```
@field_validator("field_with_validator_and_alias", "field_without_default", mode="before")
@classmethod
def check_max_length_ten(cls, v) -> str:
    """Show corresponding field with link/anchor."""
    if len(v) >= 10:
        raise ValueError("No more than 10 characters allowed")
    return v
```

#### lowercase_only

```
lowercase_only(data: dict[str, Any]) -> dict[str, Any]
```

Ensure that the field without a default is lowercase.

Source code in `docs/examples/model_noext.py`

```
@model_validator(mode="before")
@classmethod
def lowercase_only(cls, data: dict[str, Any]) -> dict[str, Any]:
    """Ensure that the field without a default is lowercase."""
    if isinstance(data.get("field_without_default"), str):
        data["field_without_default"] = data["field_without_default"].lower()
    return data
```

### ExampleModel

Bases: `BaseModel`

An example model.

Config:

- `frozen`: `False`

Fields:

- `field_without_default` (`str`)
- `field_plain_with_validator` (`int`)
- `field_with_validator_and_alias` (`str`)
- `field_with_constraints_and_description` (`int`)

Validators:

- `check_max_length_ten` → `field_with_validator_and_alias`, `field_without_default`
- `lowercase_only`

#### field_plain_with_validator

```
field_plain_with_validator: int = 100
```

Show standard field with type annotation.

#### field_with_constraints_and_description

```
field_with_constraints_and_description: int = 5
```

Shows constraints within doc string.

#### field_with_validator_and_alias

```
field_with_validator_and_alias: str = 'FooBar'
```

Shows corresponding validator with link/anchor.

#### field_without_default

```
field_without_default: str
```

Shows the *[Required]* marker in the signature.

#### check_max_length_ten

```
check_max_length_ten(v) -> str
```

Show corresponding field with link/anchor.

Source code in `docs/examples/model_ext.py`

```
@field_validator("field_with_validator_and_alias", "field_without_default", mode="before")
@classmethod
def check_max_length_ten(cls, v) -> str:
    """Show corresponding field with link/anchor."""
    if len(v) >= 10:
        raise ValueError("No more than 10 characters allowed")
    return v
```

#### lowercase_only

```
lowercase_only(data: dict[str, Any]) -> dict[str, Any]
```

Ensure that the field without a default is lowercase.

Source code in `docs/examples/model_ext.py`

```
@model_validator(mode="before")
@classmethod
def lowercase_only(cls, data: dict[str, Any]) -> dict[str, Any]:
    """Ensure that the field without a default is lowercase."""
    if isinstance(data.get("field_without_default"), str):
        data["field_without_default"] = data["field_without_default"].lower()
    return data
```
# API

# griffe_pydantic

griffe-pydantic package.

Griffe extension for Pydantic.

Modules:

- **`common`** – Deprecated. Import from griffe_pydantic directly instead.
- **`dynamic`** – Deprecated. Import from griffe_pydantic directly instead.
- **`extension`** – Deprecated. Import from griffe_pydantic directly instead.
- **`static`** – Deprecated. Import from griffe_pydantic directly instead.

Classes:

- **`PydanticExtension`** – Griffe extension for Pydantic.

Functions:

- **`get_templates_path`** – Return the templates directory path.

## PydanticExtension

```
PydanticExtension(*, schema: bool = False)
```

Bases: `Extension`

Griffe extension for Pydantic.

Parameters:

- **`schema`** (`bool`, default: `False` ) – Whether to compute and store the JSON schema of models.

Methods:

- **`on_class_instance`** – Detect and prepare Pydantic models.
- **`on_package`** – Detect models once the whole package is loaded.

Source code in `src/griffe_pydantic/_internal/extension.py`

```
def __init__(self, *, schema: bool = False) -> None:
    """Initialize the extension.

    Parameters:
        schema: Whether to compute and store the JSON schema of models.
    """
    super().__init__()
    self._schema = schema
    self._processed: set[str] = set()
    self._recorded: list[tuple[ObjectNode, Class]] = []
```

### on_class_instance

```
on_class_instance(
    *, node: AST | ObjectNode, cls: Class, **kwargs: Any
) -> None
```

Detect and prepare Pydantic models.

Source code in `src/griffe_pydantic/_internal/extension.py`

```
def on_class_instance(self, *, node: ast.AST | ObjectNode, cls: Class, **kwargs: Any) -> None:  # noqa: ARG002
    """Detect and prepare Pydantic models."""
    # Prevent running during static analysis.
    if isinstance(node, ast.AST):
        return

    try:
        import pydantic  # noqa: PLC0415
    except ImportError:
        _logger.warning("could not import pydantic - models will not be detected")
        return

    if issubclass(node.obj, pydantic.BaseModel):
        self._recorded.append((node, cls))
```

### on_package

```
on_package(*, pkg: Module, **kwargs: Any) -> None
```

Detect models once the whole package is loaded.

Source code in `src/griffe_pydantic/_internal/extension.py`

```
def on_package(self, *, pkg: Module, **kwargs: Any) -> None:  # noqa: ARG002
    """Detect models once the whole package is loaded."""
    for node, cls in self._recorded:
        self._processed.add(cls.canonical_path)
        dynamic._process_class(node.obj, cls, processed=self._processed, schema=self._schema)
    static._process_module(pkg, processed=self._processed, schema=self._schema)
```

## get_templates_path

```
get_templates_path() -> Path
```

Return the templates directory path.

Source code in `src/griffe_pydantic/__init__.py`

```
def get_templates_path() -> Path:
    """Return the templates directory path."""
    return Path(__file__).parent / "templates"
```

## common

Deprecated. Import from `griffe_pydantic` directly instead.

## dynamic

Deprecated. Import from `griffe_pydantic` directly instead.

## extension

Deprecated. Import from `griffe_pydantic` directly instead.

## static

Deprecated. Import from `griffe_pydantic` directly instead.
